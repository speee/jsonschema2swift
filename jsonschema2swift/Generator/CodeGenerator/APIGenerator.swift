//
//  APIGenerator.swift
//  jsonschema2swift
//
//  Created by hayato.iida on 2016/08/29.
//  Copyright © 2016年 Speee, Inc. All rights reserved.
//

import Foundation

class APIGenerator {

  let rootSchema: Schema
  let links: [LinkSchema]

  init(rootSchema: Schema, links: [LinkSchema]) {
    self.rootSchema = rootSchema
    self.links = links
  }

  func generate() -> String {
    return topDocComment ++
           importCode ++
           structCode
  }

  var topDocComment: String {
    return "/// API.swift" ++
           "/// generated by jsonschema2swift" + n
  }

  var importCode: String {
    return "import Foundation" ++
           "import UIKit" ++
           "import RxMoya" ++
           "import RxSwift" + n
  }

  var structCode: String {
    return "struct API {" ++
           self.links.reduce("") {
             $0 ++ structCodeGen($1)
           } ++
           "}" ++
           ""
  }

  fileprivate func structCodeGen(_ link: LinkSchema) -> String {
    return "  /// \(link.title!)" ++
           "  ///" ++
           "  /// \(link.description!)" ++
           "  ///" ++
           "  /// - href: \(link.hrefCode)" ++
           "  /// - method: \(link.method!)" ++
           "  struct \(link.title!.snake2Camel): APITarget, APIProtocol {" ++
           "    typealias Entity = \(link.targetSchema?.typeCode() ?? "NoContentResponseEntity")" ++
           "    var configuration: Configuration" ++
           structInitCodeDoc(link) ++
           "    init(\(apiParamsCode(link, join: " "))) {" ++
           initParamsCode(link) ++
           paramsDictCodeGen(link) +
           "      configuration = Configuration.init(" ++
           "          path: \"\(pathStringCode(link))\"," ++
           "          method: .\(link.method!)," ++
           "          parameters: params," ++
           "          sampleDataString: \"\"" ++
           "      )" ++
           "    }" ++
           "  }" ++
           ""
  }


  fileprivate func enumCodeGen(_ link: LinkSchema) -> String {
    return "  case \(link.title!.snake2Camel)(\(apiParamsCode(link, join:"")))" + n
  }

  fileprivate func structParamsCode(_ link: LinkSchema) -> String {
    let block: codeBlock = {
      "\($0.0.snake2camel): \($0.0.snake2camel)"
    }
    return (link.hrefPropertiesCode(block) + link.parametersCode(block)).combineCodeBlock()
  }

  fileprivate func apiParamsCode(_ link: LinkSchema, join: String) -> String {
    let hrefBlock: codeBlock = {
      "\($0.snake2camel):\(join)\($1.typeCode())"
    }
    let paramBlock: codeBlock = {
      "\($0.snake2camel):\(join)\($1.typeCode($0))" + link.nullableCode(propertyName: $0)
    }
    return (link.hrefPropertiesCode(hrefBlock) + link.parametersCode(paramBlock)).combineCodeBlock()
  }

  fileprivate func structInitCodeDoc(_ link: LinkSchema) -> String {
    let block: codeBlock = {
      return ($1.description != nil ? "    /// - parameter \($0.snake2camel): \($1.description!)" : "") +
             ($1.pattern != nil ? n + "    ///  ( pattern: \($1.pattern!) )"  : "") +
             ($1.minLength != nil ? n +  "    ///  ( minLength: \($1.minLength!) )"  : "") +
             ($1.maxLength != nil ? n +  "    ///  ( maxLength: \($1.maxLength!) )"  : "") +
             ($1.minimum != nil ? n +  "    ///  ( minimum: \($1.minimum!) )"  : "") +
             ($1.maximum != nil ? n +  "    ///  ( minimum: \($1.maximum!) )"  : "")
    }

    return (link.hrefPropertiesCode(block) + link.parametersCode(block)).combineCodeBlock(n)
  }


  var pathCode: String {
    return "  var path: String {" ++
           "    switch self {" ++
           self.links.reduce("") {
             $0 + pathCodeGen($1)
           } +
           "    }" ++
           "  }" + n
  }

  func pathCodeGen(_ link: LinkSchema) -> String {
    return "    case .\(link.title!.snake2Camel)(\(pathParamCode(link))):" ++
           "      return \"\(pathStringCode(link))\"" + n
  }

  func pathParamCode(_ link: LinkSchema) -> String {
    let params = link.apiHrefProperties.enumerated().map {
      "let \($1.0.snake2camel)"
    } + link.apiParamProperties.map {
      _, _ in
      "_"
    }
    return params.combineCodeBlock()
  }

  func pathStringCode(_ link: LinkSchema) -> String {
    return link.href.components(separatedBy: "/").filter {
      $0 != ""
    }
    .map {
      if ($0.contains("{")) {
        let path = $0.replacingOccurrences(of: "{", with: "")
        .replacingOccurrences(of: "}", with: "")
        .removingPercentEncoding
        let key = PropertySchema(byRef: path!, rootJSON: link.rootJSON)!.propertyKey
        return "\\(\(key))"
      }
      return $0
    }.reduce("") {
      $0 + "/" + $1
    }
  }


  var methodCode: String {
    return "  var method: RxMoya.Method {" ++
           "    switch self {" ++
           self.links.reduce("") {
             $0 + methodCodeGen($1)
           } +
           "    }" ++
           "  }" + n
  }

  func methodCodeGen(_ link: LinkSchema) -> String {
    return "    case .\(link.title!.snake2Camel):" ++
           "      return .\(link.method!)" + n
  }

  var paramsCode: String {
    return "  var parameters: [String: Any]? {" ++
           "    var params: [String: Any] = [:]" ++
           "    switch self {" ++
           self.links.reduce("") {
             $0 + paramsCodeGen($1)
           } +
           "    }" ++
           "  }" + n
  }

  func paramsCodeGen(_ link: LinkSchema) -> String {
    return "    case .\(link.title!.snake2Camel)(\(paramsArgsCodeGen(link))):" ++
           paramsDictCodeGen(link) +
           "      return params" + n
  }

  func paramsArgsCodeGen(_ link: LinkSchema) -> String {
    let params = link.apiHrefProperties.enumerated().map {
      _, _ in
      "_"
    } + link.apiParamProperties.enumerated().map {
      "let \($1.0.snake2camel)"
    }
    return params.combineCodeBlock()
  }

  func initParamsCode(_ link: LinkSchema) -> String {
    let immutable = link.apiParamProperties.isEmpty ? "let" : "var"
    return "      \(immutable ) params: [String: Any] = [:]"
  }

  func paramsDictCodeGen(_ link: LinkSchema) -> String {
    return link.apiParamProperties.map {
      let serializedCode = "\(link.nullableCode(propertyName: $0.0)).serialized"
      return "      params[\"\($0.0)\"] = \($0.0.snake2camel)\(serializedCode)" + n
    }.reduce("") {
      $0 + $1
    }
  }

  var tasksCode: String {
    return "  var task: Task {" ++
           "    return .request" ++
           "  }" + n
  }

  var bottomCode: String {
    return "  var sampleData: Data {" ++
           "    return \"\".UTF8EncodedData! as Data" ++
           "  }" ++
           "}" + n
  }
}

typealias codeBlock = (_ key: String, _ object: PropertySchema) -> String

extension LinkSchema {

  func hrefPropertiesCode(_ block: codeBlock) -> [String] {
    return self.apiHrefProperties.map(block)
  }

  func parametersCode(_ block: codeBlock) -> [String] {
    return self.apiParamProperties.map(block)
  }

  var apiHrefProperties: [String:PropertySchema] {
    return self.href.components(separatedBy: "/").filter {
      $0.contains("{")
    }.map {
      $0.replacingOccurrences(of: "{", with: "")
      .replacingOccurrences(of: "}", with: "")
      .removingPercentEncoding!
    }.map {
      PropertySchema(byRef: $0, rootJSON: self.rootJSON)!
    }.toDict {
      ($0!.propertyKey, $0)
    }

  }

  var hrefCode: String {
    return "/" + self.href.components(separatedBy: "/").map {
      if $0.contains("{") {
        return "{" + $0.replacingOccurrences(of: "{", with: "")
            .replacingOccurrences(of: "}", with: "")
            .removingPercentEncoding!
            .components(separatedBy: "/")
            .last! + "}"
      } else {
        return $0
      }
    }.combineCodeBlock("/")
  }

  var apiParamProperties: [String:PropertySchema] {
    return self.schema?.properties ?? [:]
  }

  var isMultipart: Bool {
    get {
      return !((self.schema?.properties?.filter {
        return $0.1.media != nil
      }.isEmpty) ?? true)
    }
  }

  func nullableCode(propertyName: String) -> String {
    if let schema = self.schema, schema.required.contains(propertyName) {
      return ""
    }
    return "?"
  }
}

extension Sequence where Iterator.Element == String {
  func combineCodeBlock(_ code: String = ", ") -> String {
    return self.reduce("") {
      "" == $0 ? $1 : $0 + code + $1
    }
  }
}
