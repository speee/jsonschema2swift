//
//  APIGenerator.swift
//  jsonschema2swift
//
//  Created by hayato.iida on 2016/08/29.
//  Copyright © 2016年 Speee, Inc. All rights reserved.
//

import Foundation

class APIGenerator {

  let rootSchema: Schema
  let links: [LinkSchema]

  init(rootSchema: Schema, links: [LinkSchema]) {
    self.rootSchema = rootSchema
    self.links = links
  }

  func generate() -> String {
    return topDocComment ++
           importCode ++
           structCode
  }

  func generateKey() -> String {
    return "/// APIKey.swift" ++
           "/// generated by jsonschema2swift" ++
           "" ++
           keyCode
  }

  var topDocComment: String {
    return "/// API.swift" ++
           "/// generated by jsonschema2swift" + n
  }

  var importCode: String {
    return "import Foundation" ++
           "import UIKit" ++
           "import RxMoya" ++
           "import RxSwift" + n
  }


  var keyCode: String {
    let keys: [String: (String, CodeClass, String)] =
        self.links
            .filter {
              $0.targetSchema?.title?.contains("data") != nil
            }
            .flatMap {
              $0.targetSchema
            }
            .flatMap {
              $0.properties!
            }
            .toDict {
              ($0.value.typeInnerCode() + ":" + $0.key, ($0.key, $0.value.codeClass(), $0.value.typeInnerCode()) )
            }

    let sortedKeys = keys.sorted {
      $0.0.key < $0.1.key
    }


    return sortedKeys.reduce("") {
      switch $1.value.1 {
      case .array:
        return $0 ++ "extension \($1.value.2): HasPluralJSONKeyEntity {" ++
               "  static let plural = \"\($1.value.0)\"" ++
               "}" + n
      default:
        return $0 ++ "extension \($1.value.2): HasSingularJSONKeyEntity {" ++
               "  static let singular = \"\($1.value.0)\"" ++
               "}" + n
      }

    }
  }

  var structCode: String {
    return "struct API {" ++
           self.links.reduce("") {
             $0 ++ structCodeGen($1)
           } ++
           "}" ++
           ""
  }

  fileprivate func structCodeGen(_ link: LinkSchema) -> String {
    return "  /// \(link.title!)" ++
           "  ///" ++
           "  /// \(link.description!.replacingOccurrences(of: "\n", with: "\n  /// "))" ++
           "  ///" ++
           "  /// - href: \(link.hrefCode)" ++
           "  /// - method: \(link.method!)" ++
           "  struct \(link.title!.snake2Camel): APITarget {" ++
           "    typealias Response = \(link.targetSchema?.responseElementCode() ?? "NoContentResponse")" ++
           "    var configuration: Configuration" ++
           structInitCodeDoc(link) ++
           "    init(\(apiParamsCode(link, join: " "))) {" ++
           initParamsCode(link) ++
           paramsDictCodeGen(link) +
           "      configuration = Configuration.init(" ++
           "        path: \"\(pathStringCode(link))\"," ++
           "        method: .\(link.method!.lowercased())," ++
           "        parameters: params," ++
           "        sampleDataString: \"\"" ++
           "      )" ++
           "    }" ++
           "  }" ++
           ""
  }


  fileprivate func enumCodeGen(_ link: LinkSchema) -> String {
    return "  case \(link.title!.snake2Camel)(\(apiParamsCode(link, join: "")))" + n
  }

  fileprivate func structParamsCode(_ link: LinkSchema) -> String {
    let block: codeBlock = {
      "\($0.0.snake2camel): \($0.0.snake2camel)"
    }
    return (link.hrefPropertiesCode(block) + link.parametersCode(block)).combineCodeBlock()
  }

  fileprivate func apiParamsCode(_ link: LinkSchema, join: String) -> String {
    let hrefBlock: codeBlock = {
      let propertyName = $1.hrefPropertyName ?? $0.snake2camel
      return "\(propertyName):\(join)\($1.typeCode())"
    }
    let paramBlock: codeBlock = {
      "\($0.snake2camel):\(join)\($1.typeCode($0))" + link.nullableCode(propertyName: $0)
    }
    return (link.hrefPropertiesCode(hrefBlock) + link.parametersCode(paramBlock)).combineCodeBlock()
  }


  fileprivate func structInitCodeDoc(_ link: LinkSchema) -> String {
    let block: codeBlock = {
      return ($1.description != nil ? "    /// - parameter \($0.snake2camel): \($1.description!)" : "") +
             ($1.pattern != nil ? n + "    ///  ( pattern: \($1.pattern!) )" : "") +
             ($1.minLength != nil ? n + "    ///  ( minLength: \($1.minLength!) )" : "") +
             ($1.maxLength != nil ? n + "    ///  ( maxLength: \($1.maxLength!) )" : "") +
             ($1.minimum != nil ? n + "    ///  ( minimum: \($1.minimum!) )" : "") +
             ($1.maximum != nil ? n + "    ///  ( minimum: \($1.maximum!) )" : "")
    }

    return (link.hrefPropertiesCode(block) + link.parametersCode(block)).combineCodeBlock(n)
  }


  var pathCode: String {
    return "  var path: String {" ++
           "    switch self {" ++
           self.links.reduce("") {
             $0 + pathCodeGen($1)
           } +
           "    }" ++
           "  }" + n
  }

  func pathCodeGen(_ link: LinkSchema) -> String {
    return "    case .\(link.title!.snake2Camel)(\(pathParamCode(link))):" ++
           "      return \"\(pathStringCode(link))\"" + n
  }

  func pathParamCode(_ link: LinkSchema) -> String {
    let params = link.apiHrefProperties.enumerated().map {
          "let \($1.0.snake2camel)"
        } + link.apiParamProperties.map {
      _, _ in
      "_"
    }
    return params.combineCodeBlock()
  }

  func pathStringCode(_ link: LinkSchema) -> String {
    return link.href.components(separatedBy: "/").filter {
          $0 != ""
        }
        .map {
          if ($0.contains("{")) {
            let path = $0.replacingOccurrences(of: "{", with: "")
                .replacingOccurrences(of: "}", with: "")
                .removingPercentEncoding
            let key = PropertySchema(byRef: path!, rootJSON: link.rootJSON)!.hrefPropertyName ??
                      PropertySchema(byRef: path!, rootJSON: link.rootJSON)!.propertyKey
            return "\\(\(key))"
          }
          return $0
        }.reduce("") {
          $0 + "/" + $1
        }
  }


  var methodCode: String {
    return "  var method: RxMoya.Method {" ++
           "    switch self {" ++
           self.links.reduce("") {
             $0 + methodCodeGen($1)
           } +
           "    }" ++
           "  }" + n
  }

  func methodCodeGen(_ link: LinkSchema) -> String {
    return "    case .\(link.title!.snake2Camel):" ++
           "      return .\(link.method!)" + n
  }

  var paramsCode: String {
    return "  var parameters: [String: Any]? {" ++
           "    var params: [String: Any] = [:]" ++
           "    switch self {" ++
           self.links.reduce("") {
             $0 + paramsCodeGen($1)
           } +
           "    }" ++
           "  }" + n
  }

  func paramsCodeGen(_ link: LinkSchema) -> String {
    return "    case .\(link.title!.snake2Camel)(\(paramsArgsCodeGen(link))):" ++
           paramsDictCodeGen(link) +
           "      return params" + n
  }

  func paramsArgsCodeGen(_ link: LinkSchema) -> String {
    let params = link.apiHrefProperties.enumerated().map {
          _, _ in
          "_"
        } + link.apiParamProperties.enumerated().map {
      "let \($1.0.snake2camel)"
    }
    return params.combineCodeBlock()
  }

  func initParamsCode(_ link: LinkSchema) -> String {
    let immutable = link.apiParamProperties.isEmpty ? "let" : "var"
    return "      \(immutable) params: [String: Any] = [:]"
  }

  func paramsDictCodeGen(_ link: LinkSchema) -> String {
    return link.apiParamProperties.map {
      let serializedCode = "\(link.nullableCode(propertyName: $0.0)).serialized"
      return "      params[\"\($0.0)\"] = \($0.0.snake2camel)\(serializedCode)" + n
    }.reduce("") {
      $0 + $1
    }
  }

  var tasksCode: String {
    return "  var task: Task {" ++
           "    return .request" ++
           "  }" + n
  }

  var bottomCode: String {
    return "  var sampleData: Data {" ++
           "    return \"\".UTF8EncodedData! as Data" ++
           "  }" ++
           "}" + n
  }
}

typealias codeBlock = (_ key: String, _ object: PropertySchema) -> String

extension LinkSchema {

  func hrefPropertiesCode(_ block: codeBlock) -> [String] {
    return self.apiHrefProperties.map(block)
  }

  func parametersCode(_ block: codeBlock) -> [String] {
    return self.apiParamProperties.map(block)
  }

  var apiHrefProperties: [String: PropertySchema] {
    return self.href.components(separatedBy: "/").filter {
      $0.contains("{")
    }.map {
      $0.replacingOccurrences(of: "{", with: "")
          .replacingOccurrences(of: "}", with: "")
          .removingPercentEncoding!
    }.map {
      PropertySchema(byRef: $0, rootJSON: self.rootJSON)!
    }.toDict {
      ($0!.hrefPropertyName ?? $0!.propertyKey, $0)
    }

  }

  var hrefCode: String {
    return "/" + self.href.components(separatedBy: "/").map {
      if $0.contains("{") {

        let ref = $0.replacingOccurrences(of: "{", with: "")
            .replacingOccurrences(of: "}", with: "")
            .removingPercentEncoding!
        let propertySchema = PropertySchema(byRef: ref, rootJSON: self.rootJSON)!
        return ":\(propertySchema.hrefPropertyName ?? propertySchema.propertyKey)"
      } else {
        return $0
      }
    }.combineCodeBlock("/")
  }

  var apiParamProperties: [String: PropertySchema] {
    return self.schema?.properties ?? [:]
  }

  var isMultipart: Bool {
    get {
      return !((self.schema?.properties?.filter {
        return $0.1.media != nil
      }.isEmpty) ?? true)
    }
  }

  func nullableCode(propertyName: String) -> String {
    if let schema = self.schema, schema.required.contains(propertyName) {
      return ""
    }
    return "?"
  }
}

extension Sequence where Iterator.Element == String {
  func combineCodeBlock(_ code: String = ", ") -> String {
    return self.reduce("") {
      "" == $0 ? $1 : $0 + code + $1
    }
  }
}


extension PropertySchema {
  var hrefPropertyName: String? {
    guard var code = self.ref else {
      return nil
    }
    code = replaseString(code: code, replace: "#", template: "")
    code = replaseString(code: code, replace: "definitions", template: "/")
    code = replaseString(code: code, replace: "/+", template: "_")
    code = replaseString(code: code, replace: "^_", template: "")
    code = replaseString(code: code, replace: "_$", template: "")
    return code.snake2camel
  }
}


